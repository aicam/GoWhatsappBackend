# Messenger backend with RSA-1024 and AES-128

This repository contains a full backend to build a messenger with option to send messages and 
files with secure encryption at the same time.
The security strategy is almost same as <a href="https://scontent.whatsapp.net/v/t61.22868-34/68135620_760356657751682_6212997528851833559_n.pdf/WhatsApp-Security-Whitepaper.pdf?_nc_sid=41cc27&_nc_oc=AQkJcUSq9G6NGOZ0ZuRULw_icW7l1Fq-HLh2i2KELDnTOnkpgfZCeAUpQU3pa7mkSLQ&_nc_ht=scontent.whatsapp.net&oh=1a7c6a379166027b672825a7f84c6ec9&oe=5ECCDC93">Whatsapp</a>.


## Getting Started

You have two options to run the server, I myself highly recommend using its docker in dockerhub and docker-compose which is uploaded.
If you want to build this with customized options you should change two pivotal files: main.go and redis.go they both have settings for
mysql and redis connection.

### Prerequisites

Encryption for messages is based on AES-128 with HEX encoding.
Install all requirments by

```
go mod download
```

### Run
The easiest way is to deploy it by `docker-compose up`. However 
in `main.go` the server run on port 4300. You can install Redis and MySQL 
separately to deploy it on your server.

### File transfer
Files are being transferred by chunks which can be determined
by front end. The common format is 1024KB of base64
encoded binary data of file in each chunk but you can use any other formats
that are compatible with MySQL utf8mb data format.

### Hash & Crypto standards
Currently, there is no route to add users to database.
In this regard, username and passwords should be added separately to 
database. Each request has a JWT (refer <a href="https://github.com/dgrijalva/jwt-go">Go JWT library</a>)
header which is tokenized by username password.<br>
Each message and file chunk is encrypted with AES with
a token generated randomly for each session. Messages are stored
decrypted, however file chunks are stored encrypted with session token, 
so they can be decrypted after token changed.<br>
Token is returned to client encrypted with RSA user public key, so
it wouldn't be leaked by sniffing network.
HMAC is also generated by encrypted data for 
authenticate check.

### Requests format
Server consider itself and client as p2p messenger users. Public key
is attached to each request send and return by server, each generated
in users side (one in front-end and one in server). Server public key is
consistent each time it is run. If the server restart, public key will change.
Client need to generate a JWT with its password and a RSA key pairs and
send public key in `Info` object in request.
Server will send session key if is not created yet or client asked in
`token_requested` parameter in `Info` in request json.
There is only one request to the server, and the format structure is presented at request.go.
Here is a simple example for handshaking.
```
{
  "info": {
    "token_requested": true,
    "src_username": "aicam",
    "dest_username": "sijal",
    "public_key": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCi8sMm2CUQrxju5TVdF7u6iAxxa4sdIkBPARR0TaZTZUcmp+ySmCGXVM68h02M2nui/vCHmxLxbPH34cg3Ul8LoS8MNZIqDk2qekbaRA1s/ehL3kU4chw8050x15XCp9k9y4Q2LrZr/pkoXY23tk7PYT0LOcjKCOe7z/cf1SMcTwIDAQAB\n-----END PUBLIC KEY-----"
  },
  "message": {
    "text": "",
    "offset": 2,
    "hmac": ""
  },
  "file": {
    "data": "",
    "chunk": 0,
    "finished": false,
    "file_name": "",
    "hmac": ""
  }
}

```
